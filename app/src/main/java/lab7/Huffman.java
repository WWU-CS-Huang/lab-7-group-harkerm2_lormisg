/*
 * This source file was generated by the Gradle 'init' task
 */
package lab7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Hashtable;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Huffman {

    static Hashtable<Integer, String> huffmanCodes = new Hashtable<>();
    static Hashtable<Integer, Integer> map = new Hashtable<>();
    static StringBuilder encode = new StringBuilder();


    public static void main(String[] args) { // Change to execute the given methods below

        String filename = args[0];
        StringBuilder inputBuild = new StringBuilder();
        try (Scanner scanner = new Scanner(new File(filename))){
            while (scanner.hasNextLine()){
                inputBuild.append(scanner.nextLine()); //stringBuilder will now contain entire text file
                inputBuild.append('\n');
            }
        } catch (FileNotFoundException e) {
            System.out.print(e);
        }
        String input = inputBuild.toString(); //convert back to string
        Scanner freqScanner = new Scanner(input);
        countFrequency(freqScanner); //count frequency of each char in input

        Node root = buildTree(map);

        Encoder(root,"");
        Scanner encodeScanner = new Scanner(input);
        encode = new StringBuilder();
        Encode(encodeScanner);

        String encodedString = encodeScanner.toString();
        String decodedString = Decode(encodedString, root);

        if (input.length() < 100) {
            System.out.println("Input string: " + input);
            System.out.println("Encoded string: " + encodedString);
            System.out.println("Decoded string: " + decodedString);
        }

        boolean equiv = input.equals(decodedString);
        double compRatio = (double) encodedString.length() / (input.length()*8.0);

        System.out.println("Decoded equals input: " + equiv);
        System.out.println("Compression ratio: " + compRatio);
        
    }

    public static void Encoder(Node root, String cur){
        if (root == null){
            return;
        }

        if (root.left == null && root.right == null) {
            huffmanCodes.put(root.key, cur);
            return;
        }

        Encoder(root.left, cur + "0");
        Encoder(root.right, cur +"1");
    }

    public static void Encode(Scanner scan){
        while (scan.hasNextLine()){
            String a = scan.nextLine();

            for (int i = 0; i < a.length(); i++){
                int ascii = (int) a.charAt(i);
                encode.append(huffmanCodes.get(ascii));
            }
        encode.append(huffmanCodes.get((int) '\n'));
        }
    }
        // 

    /**
     * methods:
     * Count Frequency
     * Build the tree based on count frequency
     * {Decoder
     * Encoder} - Based on huff.
     * 
     */

    public static void countFrequency (Scanner scan){
        while (scan.hasNextLine()){
            String a = scan.nextLine();

            for (int i = 0; i < a.length(); i++){
                int ascii = (int) a.charAt(i);
                if (map.containsKey(ascii) != true){ // if key not present, add and can assume first instance
                    map.put(ascii, 1);
                    continue;
                }
                int curVal = map.get(ascii);
                map.put(ascii, curVal + 1);
            }
            int newLine = (int) '\n';
            if (map.containsKey(newLine) != true){
                map.put(newLine, 1);
            } else {
                map.put(newLine, map.get(newLine) + 1);
            }
            
        }
        System.out.println(map.toString());
    }
/*
 * Takes in the frequency table and uses the priority queue to build the tree.
 * Returns the root of the Huffman tree that was built.
 */
    public static Node buildTree(Hashtable<Integer,Integer> m){
        PriorityQueue<Node> pq = new PriorityQueue<>();

        for (Map.Entry<Integer,Integer> entry : m.entrySet()){ //adding all the nodes that represent a char's frequency into the pq
            int ascii = entry.getKey();
            int freq = entry.getValue();
            Node node = new Node(freq, null, null);
            node.key = ascii;
            pq.add(node);
        }

        while (pq.size() > 1){ //while there's still at least two entrys to combine, do so
            Node left = pq.poll();
            Node right = pq.poll(); //poll returns two lowest freq's due to priority queue
            Node parent = new Node(left.freq+right.freq, left, right); //combination node
            pq.add(parent);
    }
        return pq.poll(); //final node is the root of the tree

    }

    public static String Decode(String encoded, Node root){ //pass in root of huffman tree, and pass in .toString() of the encoded StringBuilder
        StringBuilder decoded = new StringBuilder();
        Node cur = root;
        for (int i = 0; i < encoded.length(); i++){
            char bit = encoded.charAt(i);
            if (bit=='0'){
                cur = cur.left;
            } else if (bit=='1'){
                cur = cur.right;
            }

            if (cur.left==null && cur.right==null){
                decoded.append((char) cur.key);
                cur = root; //reset cur for decoding next char
            }
        }
        return decoded.toString();
    }

    static class Node implements Comparable<Node>{
        int key;
        int freq;
        Node left,right;

        Node(int freq, Node left, Node right){
            this.key = -1; //default for nodes that represent non-characters (combination nodes in huffman)
            this.freq = freq;
            this.left = left;
            this.right = right;
        }
        @Override
        public int compareTo(Node n){
            return this.freq - n.freq;
        }
    }
    
}
