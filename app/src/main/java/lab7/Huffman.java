/*
 * This source file was generated by the Gradle 'init' task
 */
package lab7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Hashtable;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Huffman {

    static Hashtable<Integer, String> huffmanCodes = new Hashtable<>();
    static Hashtable<Integer, Integer> map = new Hashtable<>();
    static String encode = "";


    public static void main(String[] args) { // Change to execute the given methods below

        map = new Hashtable<>();
        String filename = args[0];
        Scanner scanner = null;
        try {
            scanner = new Scanner(new File(filename));
        } catch (FileNotFoundException e) {
            System.out.print(e);
        }
        
        Huffman huffman = new Huffman();

        huffman.countFrequency(scanner);
        Node root = huffman.buildTree(map);
        huffman.Encoder(root, "");
    }

    public static void Encoder(Node root, String cur){
        if (root == null){
            return;
        }

        if (root.left == null && root.right == null) {
            huffmanCodes.put(root.key, cur);
            return;
        }

        Encoder(root.left, cur + "0");
        Encoder(root.right, cur +"1");
    }

    public static void Encode(Scanner scan){
        while (scan.hasNextLine()){
            String a = scan.nextLine();

            for (int i = 0; i < a.length(); i++){
                int ascii = (int) a.charAt(i);
                encode += huffmanCodes.get(ascii);
            }
        encode += huffmanCodes.get((int) '\n');
        }
    }
        // 

    /**
     * methods:
     * Count Frequency
     * Build the tree based on count frequency
     * {Decoder
     * Encoder} - Based on huff.
     * 
     */

    public static void countFrequency (Scanner scan){
        while (scan.hasNextLine()){
            String a = scan.nextLine();

            for (int i = 0; i < a.length(); i++){
                int ascii = (int) a.charAt(i);
                if (map.containsKey(ascii) != true){ // if key not present, add and can assume first instance
                    map.put(ascii, 1);
                    continue;
                }
                int curVal = map.get(ascii);
                map.put(ascii, curVal + 1);
            }
            int newLine = (int) '\n';
            if (map.containsKey(newLine) != true){
                map.put(newLine, 1);
            } else {
                map.put(newLine, map.get(newLine) + 1);
            }
            
        }
        System.out.println(map.toString());
    }
    /*
     * Returns array pair in key,value order of the key with the minimum value (frequency) then deletes the map entry
     */
    //public static int[] getHashMin(Hashtable<Integer,Integer> m){
        //int min = Integer.MAX_VALUE; //will always be replaced
        //int minKey = 0; //also always gets replaced with an ASCII code
        //for (Map.Entry<Integer, Integer> item : m.entrySet()){
          //  if (item.getValue() < min){
            //    min = item.getValue();
              //  minKey = item.getKey();
            //}
        //}
        //int[] a = new int[2];
        //a[0] = minKey;
        //a[1] = min;
        //map.remove(minKey);
        //return a;
    //}        

/*
 * Takes in the frequency table and uses the priority queue to build the tree.
 * Returns the root of the Huffman tree that was built.
 */
    public static Node buildTree(Hashtable<Integer,Integer> m){
        PriorityQueue<Node> pq = new PriorityQueue<>();

        for (Map.Entry<Integer,Integer> entry : m.entrySet()){ //adding all the nodes that represent a char's frequency into the pq
            int ascii = entry.getKey();
            int freq = entry.getValue();
            Node node = new Node(freq, null, null);
            node.key = ascii;
            pq.add(node);
        }

        while (pq.size() > 1){ //while there's still at least two entrys to combine, do so
            Node left = pq.poll();
            Node right = pq.poll(); //poll returns two lowest freq's due to priority queue
            Node parent = new Node(left.freq+right.freq, left, right); //combination node
            pq.add(parent);
    }
        return pq.poll(); //final node is the root of the tree

    }

    public static String Decode(String encoded, Node root){ //pass in root of huffman tree
        StringBuilder decoded = new StringBuilder();
        Node cur = root;
        for (int i = 0; i < encoded.length(); i++){
            char bit = encoded.charAt(i);
            if (bit=='0'){
                cur = cur.left;
            } else if (bit=='1'){
                cur = cur.right;
            }

            if (cur.left==null && cur.right==null){
                decoded.append((char) cur.key);
                cur = root; //reset cur for decoding next char
            }
        }
        return decoded.toString();
    }

    static class Node implements Comparable<Node>{
        int key;
        int freq;
        Node left,right;

        Node(int freq, Node left, Node right){
            this.key = -1; //default for nodes that represent non-characters (combination nodes in huffman)
            this.freq = freq;
            this.left = left;
            this.right = right;
        }
        @Override
        public int compareTo(Node n){
            return this.freq - n.freq;
        }
    }
    
}
