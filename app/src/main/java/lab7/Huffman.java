/*
 * This source file was generated by the Gradle 'init' task
 */
package lab7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Hashtable;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Huffman {

    static class Node implements Comparable<Node>{
        int key;
        int freq;
        Node left,right;

        Node(int freq, Node left, Node right){
            this.key = -1; //default for nodes that represent non-characters (combination nodes in huffman)
            this.freq = freq;
            this.left = left;
            this.right = right;
        }
        @Override
        public int compareTo(Node n){
            return this.freq - n.freq;
        }
    }

    static Hashtable<Integer, Integer> map = new Hashtable<>();
    public static void main(String[] args) { // Change to execute the given methods below

        map = new Hashtable<>();
        String filename = args[0];
        try {
            Scanner scanner = new Scanner(new File(filename));
        } catch (FileNotFoundException e) {
            System.out.print(e);
        }
        
    }

    /**
     * methods:
     * Count Frequency
     * Build the tree based on count frequency
     * {Decoder
     * Encoder} - Based on huff.
     * 
     */

    public static void countFrequency (Scanner scan){
        while (scan.hasNextLine()){
            String a = scan.nextLine();

            for (int i = 0; i < a.length(); i++){
                int ascii = (int) a.charAt(i);
                if (map.containsKey(ascii) != true){ // if key not present, add and can assume first instance
                    map.put(ascii, 1);
                    continue;
                }
                int curVal = map.get(ascii);
                map.put(ascii, curVal + 1);
            }
        }
        System.out.println(map.toString());
    }
    /*
     * Returns array pair in key,value order of the key with the minimum value (frequency) then deletes the map entry
     */
    //public static int[] getHashMin(Hashtable<Integer,Integer> m){
        //int min = Integer.MAX_VALUE; //will always be replaced
        //int minKey = 0; //also always gets replaced with an ASCII code
        //for (Map.Entry<Integer, Integer> item : m.entrySet()){
          //  if (item.getValue() < min){
            //    min = item.getValue();
              //  minKey = item.getKey();
            //}
        //}
        //int[] a = new int[2];
        //a[0] = minKey;
        //a[1] = min;
        //map.remove(minKey);
        //return a;
    //}        

/*
 * Takes in the frequency table and uses the priority queue to build the tree.
 * Returns the root of the Huffman tree that was built.
 */
    public static Node buildTree(Hashtable<Integer,Integer> m){
        PriorityQueue<Node> pq = new PriorityQueue<>();

        for (Map.Entry<Integer,Integer> entry : m.entrySet()){ //adding all the nodes that represent a char's frequency into the pq
            int ascii = entry.getKey();
            int freq = entry.getValue();
            Node node = new Node(freq, null, null);
            node.key = ascii;
            pq.add(node);
        }

        while (pq.size() > 1){ //while there's still at least two entrys to combine, do so
            Node left = pq.poll();
            Node right = pq.poll(); //poll returns two lowest freq's due to priority queue
            Node parent = new Node(left.freq+right.freq, left, right); //combination node
            pq.add(parent);
    }
        return pq.poll(); //final node is the root of the tree

    }
}
